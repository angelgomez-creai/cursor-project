---
title: "Módulo 4: Desarrollo Frontend con Cursor AI"
description: Transforma arquitectura legacy a feature-based, implementa React patterns modernos, state management avanzado, API integration y optimización de performance.
---

import { Card, CardGrid } from '@astrojs/starlight/components';

## Objetivos de Aprendizaje

Al finalizar este módulo, serás capaz de:

1. **Transformar** arquitectura frontend legacy a **feature-based architecture** escalable
2. **Implementar React patterns avanzados**: Compound Components, Render Props, y Custom Hooks
3. **Gestionar estado complejo** con Context API y React Query para cache inteligente
4. **Integrar APIs** con patterns profesionales de error handling y optimización
5. **Optimizar performance** con React.memo, lazy loading y code splitting
6. **Desarrollar testing automatizado** con Jest, React Testing Library y E2E testing

## Introducción Conceptual

El desarrollo frontend moderno va más allá de crear componentes que "funcionan"—se trata de **arquitectar sistemas escalables** que puedan evolucionar con equipos de desarrollo crecientes y requerimientos cambiantes. Este módulo te enseña a usar Cursor AI para transformar aplicaciones frontend legacy en **arquitecturas empresariales robustas**.

La **Feature-Based Architecture** es el estándar de facto para aplicaciones React empresariales porque resuelve los problemas fundamentales del frontend: escalabilidad, mantenibilidad, testabilidad y colaboración en equipo. Aprenderás a implementar esta arquitectura usando Cursor AI como tu copiloto de desarrollo.

Al final de este módulo, habrás transformado un frontend básico en una **aplicación enterprise-ready** con patrones modernos, performance optimizada y testing automatizado.

## Feature-Based Architecture

### ¿Por qué Feature-Based Architecture?

#### Problemas del Frontend Legacy

```typescript
// ❌ ANTES: Estructura plana y desordenada
src/
├── components/
│   ├── Header.tsx
│   ├── Footer.tsx
│   ├── ProductCard.tsx
│   ├── UserProfile.tsx
│   └── OrderList.tsx
├── pages/
│   ├── HomePage.tsx
│   ├── ProductsPage.tsx
│   └── OrdersPage.tsx
└── utils/
    ├── api.ts
    └── helpers.ts
```

#### Solución: Feature-Based Architecture

```typescript
// ✅ DESPUÉS: Organización por funcionalidad
src/
├── features/
│   ├── Auth/
│   │   ├── components/
│   │   ├── pages/
│   │   ├── store/
│   │   └── utils/
│   ├── Products/
│   │   ├── components/
│   │   ├── pages/
│   │   ├── store/
│   │   └── utils/
│   └── Orders/
│       ├── components/
│       ├── pages/
│       ├── store/
│       └── utils/
├── shared/
│   ├── components/
│   ├── hooks/
│   └── utils/
└── App.tsx
```

### Beneficios de la Arquitectura Moderna

<CardGrid>
  <Card title="🔧 Escalabilidad" icon="rocket">
    Fácil agregar nuevas features sin romper código existente
  </Card>
  
  <Card title="🛠️ Mantenibilidad" icon="setting">
    Código organizado y predecible con responsabilidades claras
  </Card>
  
  <Card title="♻️ Reutilización" icon="puzzle">
    Componentes compartidos optimizados para toda la aplicación
  </Card>
  
  <Card title="🧪 Testing" icon="approve-check">
    Tests aislados por feature con mocking simplificado
  </Card>
</CardGrid>

### Principios Fundamentales

#### 1. Separación por Dominio

```typescript
// Cada feature representa un dominio de negocio
features/
├── Auth/          // Autenticación y autorización
├── Products/      // Gestión de productos
├── Orders/        // Gestión de órdenes
├── Users/         // Gestión de usuarios
└── Admin/         // Panel administrativo
```

#### 2. Estructura Interna de Features

```typescript
features/Products/
├── components/    // Componentes específicos del dominio
│   ├── ProductCard.tsx
│   ├── ProductList.tsx
│   └── ProductDetail.tsx
├── pages/         // Páginas del dominio
│   ├── ProductsPage.tsx
│   └── ProductDetailPage.tsx
├── store/         // Estado local del dominio
│   ├── productsSlice.ts
│   └── productsActions.ts
├── hooks/         // Hooks específicos del dominio
│   ├── useProducts.ts
│   └── useProduct.ts
├── utils/         // Utilidades del dominio
│   ├── productHelpers.ts
│   └── productValidators.ts
└── types/         // Tipos TypeScript del dominio
    └── product.types.ts
```

### Implementación Práctica

#### Ejemplo: Feature Products

```typescript
// features/Products/types/product.types.ts
export interface Product {
  id: number;
  name: string;
  price: number;
  description: string;
  category: string;
  stock: number;
  imageUrl?: string;
}

export interface ProductFilters {
  category?: string;
  minPrice?: number;
  maxPrice?: number;
  search?: string;
}

// features/Products/hooks/useProducts.ts
import { useState, useEffect } from 'react';
import { Product, ProductFilters } from '../types/product.types';
import { productsApi } from '../utils/productsApi';

export const useProducts = (filters?: ProductFilters) => {
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchProducts = async () => {
      try {
        setLoading(true);
        const data = await productsApi.getProducts(filters);
        setProducts(data);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Error fetching products');
      } finally {
        setLoading(false);
      }
    };

    fetchProducts();
  }, [filters]);

  return { products, loading, error };
};
```

## React Patterns Avanzados

### 1. Compound Components Pattern

#### Ejemplo: ProductCard con Variantes

```tsx
// features/Products/components/ProductCard/ProductCard.tsx
import React from 'react';
import { Product } from '../../types/product.types';

interface ProductCardProps {
  product: Product;
  variant?: 'default' | 'compact' | 'detailed';
  onAddToCart?: (product: Product) => void;
  onViewDetails?: (product: Product) => void;
}

export const ProductCard: React.FC<ProductCardProps> = ({
  product,
  variant = 'default',
  onAddToCart,
  onViewDetails
}) => {
  const renderContent = () => {
    switch (variant) {
      case 'compact':
        return <ProductCardCompact product={product} />;
      case 'detailed':
        return <ProductCardDetailed product={product} />;
      default:
        return <ProductCardDefault product={product} />;
    }
  };

  return (
    <div className={`product-card product-card--${variant}`}>
      {renderContent()}
      <div className="product-card__actions">
        {onViewDetails && (
          <button onClick={() => onViewDetails(product)}>
            Ver Detalles
          </button>
        )}
        {onAddToCart && (
          <button onClick={() => onAddToCart(product)}>
            Agregar al Carrito
          </button>
        )}
      </div>
    </div>
  );
};

// Sub-componentes
const ProductCardDefault: React.FC<{ product: Product }> = ({ product }) => (
  <div className="product-card__content">
    <img src={product.imageUrl} alt={product.name} />
    <h3>{product.name}</h3>
    <p className="price">${product.price}</p>
  </div>
);

const ProductCardCompact: React.FC<{ product: Product }> = ({ product }) => (
  <div className="product-card__content--compact">
    <h4>{product.name}</h4>
    <p>${product.price}</p>
  </div>
);

const ProductCardDetailed: React.FC<{ product: Product }> = ({ product }) => (
  <div className="product-card__content--detailed">
    <img src={product.imageUrl} alt={product.name} />
    <h3>{product.name}</h3>
    <p className="description">{product.description}</p>
    <p className="price">${product.price}</p>
    <p className="stock">Stock: {product.stock}</p>
    <p className="category">{product.category}</p>
  </div>
);
```

### 2. Render Props Pattern

#### Ejemplo: Data Fetcher Reutilizable

```tsx
// shared/components/DataFetcher/DataFetcher.tsx
import React, { useState, useEffect } from 'react';

interface DataFetcherProps<T> {
  url: string;
  children: (data: T[], loading: boolean, error: string | null) => React.ReactNode;
}

export function DataFetcher<T>({ url, children }: DataFetcherProps<T>) {
  const [data, setData] = useState<T[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const result = await response.json();
        setData(result);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Error fetching data');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [url]);

  return <>{children(data, loading, error)}</>;
}

// Uso en Products
<DataFetcher url="/api/products">
  {(products, loading, error) => {
    if (loading) return <div>Cargando productos...</div>;
    if (error) return <div>Error: {error}</div>;
    return <ProductList products={products} />;
  }}
</DataFetcher>
```

### 3. Custom Hooks Pattern

#### Ejemplo: useLocalStorage Hook

```typescript
// shared/hooks/useLocalStorage.ts
import { useState, useEffect } from 'react';

export function useLocalStorage<T>(key: string, initialValue: T) {
  // Estado para almacenar nuestro valor
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Función para establecer el valor
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      window.localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue] as const;
}

// Uso en Cart
const [cartItems, setCartItems] = useLocalStorage<CartItem[]>('cart', []);
```

## State Management con Context API

### Implementación de Context API

#### 1. Auth Context

```tsx
// features/Auth/context/AuthContext.tsx
import React, { createContext, useContext, useReducer, ReactNode } from 'react';

interface User {
  id: number;
  email: string;
  name: string;
  role: 'customer' | 'admin';
}

interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  loading: boolean;
}

type AuthAction =
  | { type: 'LOGIN_START' }
  | { type: 'LOGIN_SUCCESS'; payload: { user: User; token: string } }
  | { type: 'LOGIN_FAILURE'; payload: string }
  | { type: 'LOGOUT' }
  | { type: 'UPDATE_USER'; payload: User };

const initialState: AuthState = {
  user: null,
  token: null,
  isAuthenticated: false,
  loading: false,
};

function authReducer(state: AuthState, action: AuthAction): AuthState {
  switch (action.type) {
    case 'LOGIN_START':
      return { ...state, loading: true };
    case 'LOGIN_SUCCESS':
      return {
        ...state,
        user: action.payload.user,
        token: action.payload.token,
        isAuthenticated: true,
        loading: false,
      };
    case 'LOGIN_FAILURE':
      return {
        ...state,
        user: null,
        token: null,
        isAuthenticated: false,
        loading: false,
      };
    case 'LOGOUT':
      return {
        ...state,
        user: null,
        token: null,
        isAuthenticated: false,
      };
    case 'UPDATE_USER':
      return {
        ...state,
        user: action.payload,
      };
    default:
      return state;
  }
}

interface AuthContextType extends AuthState {
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  updateUser: (user: User) => void;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(authReducer, initialState);

  const login = async (email: string, password: string) => {
    try {
      dispatch({ type: 'LOGIN_START' });
      
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, password }),
      });

      if (!response.ok) {
        throw new Error('Login failed');
      }

      const { user, token } = await response.json();
      dispatch({ type: 'LOGIN_SUCCESS', payload: { user, token } });
    } catch (error) {
      dispatch({ 
        type: 'LOGIN_FAILURE', 
        payload: error instanceof Error ? error.message : 'Login failed' 
      });
    }
  };

  const logout = () => {
    dispatch({ type: 'LOGOUT' });
  };

  const updateUser = (user: User) => {
    dispatch({ type: 'UPDATE_USER', payload: user });
  };

  return (
    <AuthContext.Provider value={{ ...state, login, logout, updateUser }}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
```

## API Integration Patterns

### 1. API Client con Axios

#### Configuración Base

```typescript
// shared/utils/apiClient.ts
import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

class ApiClient {
  private client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: process.env.REACT_APP_API_URL || 'http://localhost:8000',
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    this.setupInterceptors();
  }

  private setupInterceptors() {
    // Request interceptor para agregar token
    this.client.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('token');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor para manejar errores
    this.client.interceptors.response.use(
      (response) => response,
      (error) => {
        if (error.response?.status === 401) {
          localStorage.removeItem('token');
          window.location.href = '/login';
        }
        return Promise.reject(error);
      }
    );
  }

  async get<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response: AxiosResponse<T> = await this.client.get(url, config);
    return response.data;
  }

  async post<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response: AxiosResponse<T> = await this.client.post(url, data, config);
    return response.data;
  }

  async put<T>(url: string, data?: any, config?: AxiosRequestConfig): Promise<T> {
    const response: AxiosResponse<T> = await this.client.put(url, data, config);
    return response.data;
  }

  async delete<T>(url: string, config?: AxiosRequestConfig): Promise<T> {
    const response: AxiosResponse<T> = await this.client.delete(url, config);
    return response.data;
  }
}

export const apiClient = new ApiClient();
```

### 2. React Query para Cache y Estado

#### Configuración de React Query

```tsx
// shared/providers/QueryProvider.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactQueryDevtools } from '@tanstack/react-query-devtools';
import { ReactNode } from 'react';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutos
      cacheTime: 10 * 60 * 1000, // 10 minutos
      retry: 3,
      refetchOnWindowFocus: false,
    },
  },
});

export function QueryProvider({ children }: { children: ReactNode }) {
  return (
    <QueryClientProvider client={queryClient}>
      {children}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}
```

#### Custom Hooks con React Query

```typescript
// features/Products/hooks/useProductsQuery.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { productsApi } from '../services/productsApi';
import { Product, ProductFilters, CreateProductData } from '../types/product.types';

export function useProducts(filters?: ProductFilters) {
  return useQuery({
    queryKey: ['products', filters],
    queryFn: () => productsApi.getProducts(filters),
  });
}

export function useProduct(id: number) {
  return useQuery({
    queryKey: ['product', id],
    queryFn: () => productsApi.getProduct(id),
    enabled: !!id,
  });
}

export function useCreateProduct() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateProductData) => productsApi.createProduct(data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['products'] });
    },
  });
}

export function useUpdateProduct() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, data }: { id: number; data: Partial<CreateProductData> }) =>
      productsApi.updateProduct(id, data),
    onSuccess: (_, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['products'] });
      queryClient.invalidateQueries({ queryKey: ['product', id] });
    },
  });
}
```

## Performance Optimization

### 1. React.memo para Memoización

#### Ejemplo: ProductCard Optimizado

```tsx
// features/Products/components/ProductCard/ProductCard.tsx
import React, { memo } from 'react';
import { Product } from '../../types/product.types';

interface ProductCardProps {
  product: Product;
  onAddToCart: (product: Product) => void;
  onViewDetails: (product: Product) => void;
}

export const ProductCard = memo<ProductCardProps>(({ 
  product, 
  onAddToCart, 
  onViewDetails 
}) => {
  const handleAddToCart = () => {
    onAddToCart(product);
  };

  const handleViewDetails = () => {
    onViewDetails(product);
  };

  return (
    <div className="product-card">
      <img src={product.imageUrl} alt={product.name} />
      <h3>{product.name}</h3>
      <p className="price">${product.price}</p>
      <div className="product-card__actions">
        <button onClick={handleViewDetails}>Ver Detalles</button>
        <button onClick={handleAddToCart}>Agregar al Carrito</button>
      </div>
    </div>
  );
});

ProductCard.displayName = 'ProductCard';
```

### 2. useMemo y useCallback

#### Ejemplo: ProductList Optimizado

```tsx
// features/Products/components/ProductList/ProductList.tsx
import React, { useMemo, useCallback } from 'react';
import { ProductCard } from '../ProductCard/ProductCard';
import { Product } from '../../types/product.types';

interface ProductListProps {
  products: Product[];
  onAddToCart: (product: Product) => void;
  onViewDetails: (product: Product) => void;
  filters?: {
    category?: string;
    minPrice?: number;
    maxPrice?: number;
  };
}

export const ProductList: React.FC<ProductListProps> = ({
  products,
  onAddToCart,
  onViewDetails,
  filters
}) => {
  // Memoizar productos filtrados
  const filteredProducts = useMemo(() => {
    return products.filter(product => {
      if (filters?.category && product.category !== filters.category) {
        return false;
      }
      if (filters?.minPrice && product.price < filters.minPrice) {
        return false;
      }
      if (filters?.maxPrice && product.price > filters.maxPrice) {
        return false;
      }
      return true;
    });
  }, [products, filters]);

  // Memoizar callbacks
  const handleAddToCart = useCallback((product: Product) => {
    onAddToCart(product);
  }, [onAddToCart]);

  const handleViewDetails = useCallback((product: Product) => {
    onViewDetails(product);
  }, [onViewDetails]);

  return (
    <div className="product-list">
      {filteredProducts.map(product => (
        <ProductCard
          key={product.id}
          product={product}
          onAddToCart={handleAddToCart}
          onViewDetails={handleViewDetails}
        />
      ))}
    </div>
  );
};
```

### 3. Lazy Loading y Code Splitting

#### Ejemplo: Route-based Code Splitting

```tsx
// App.tsx
import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { LoadingSpinner } from './shared/components/LoadingSpinner';

// Lazy load pages
const HomePage = lazy(() => import('./features/Home/pages/HomePage'));
const ProductsPage = lazy(() => import('./features/Products/pages/ProductsPage'));
const ProductDetailPage = lazy(() => import('./features/Products/pages/ProductDetailPage'));
const OrdersPage = lazy(() => import('./features/Orders/pages/OrdersPage'));
const LoginPage = lazy(() => import('./features/Auth/pages/LoginPage'));

export function App() {
  return (
    <Router>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<HomePage />} />
          <Route path="/products" element={<ProductsPage />} />
          <Route path="/products/:id" element={<ProductDetailPage />} />
          <Route path="/orders" element={<OrdersPage />} />
          <Route path="/login" element={<LoginPage />} />
        </Routes>
      </Suspense>
    </Router>
  );
}
```

## Testing Frontend

### 1. Unit Testing con Jest y React Testing Library

#### Ejemplo: Test de ProductCard

```tsx
// features/Products/components/ProductCard/__tests__/ProductCard.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { ProductCard } from '../ProductCard';
import { Product } from '../../../types/product.types';

const mockProduct: Product = {
  id: 1,
  name: 'Test Product',
  price: 99.99,
  description: 'Test description',
  category: 'Electronics',
  stock: 10,
  imageUrl: 'test-image.jpg',
};

const mockOnAddToCart = jest.fn();
const mockOnViewDetails = jest.fn();

describe('ProductCard', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('renders product information correctly', () => {
    render(
      <ProductCard
        product={mockProduct}
        onAddToCart={mockOnAddToCart}
        onViewDetails={mockOnViewDetails}
      />
    );

    expect(screen.getByText('Test Product')).toBeInTheDocument();
    expect(screen.getByText('$99.99')).toBeInTheDocument();
    expect(screen.getByText('Electronics')).toBeInTheDocument();
    expect(screen.getByAltText('Test Product')).toHaveAttribute('src', 'test-image.jpg');
  });

  it('calls onAddToCart when add to cart button is clicked', () => {
    render(
      <ProductCard
        product={mockProduct}
        onAddToCart={mockOnAddToCart}
        onViewDetails={mockOnViewDetails}
      />
    );

    const addToCartButton = screen.getByText('Agregar al Carrito');
    fireEvent.click(addToCartButton);

    expect(mockOnAddToCart).toHaveBeenCalledWith(mockProduct);
  });

  it('calls onViewDetails when view details button is clicked', () => {
    render(
      <ProductCard
        product={mockProduct}
        onAddToCart={mockOnAddToCart}
        onViewDetails={mockOnViewDetails}
      />
    );

    const viewDetailsButton = screen.getByText('Ver Detalles');
    fireEvent.click(viewDetailsButton);

    expect(mockOnViewDetails).toHaveBeenCalledWith(mockProduct);
  });
});
```

## Ejercicios Prácticos

### Ejercicio 1: Transformar a Feature-Based Architecture

<CardGrid>
  <Card title="📋 Objetivo" icon="document">
    Refactorizar el frontend legacy del proyecto e-commerce a una arquitectura feature-based escalable
  </Card>
  
  <Card title="🎯 Criterios de Evaluación" icon="approve-check">
    - Estructura feature-based implementada
    - Componentes legacy migrados correctamente  
    - Tipos TypeScript bien definidos
    - Separación clara de responsabilidades
  </Card>
</CardGrid>

#### Prompts para Cursor AI

```typescript
// 1. Análisis del Código Legacy
@cursor: "Analiza el código actual del frontend del proyecto e-commerce y identifica los problemas de arquitectura. Sugiere una estructura feature-based específica para este proyecto"

// 2. Crear Estructura de Carpetas
@cursor: "Crea la estructura completa de carpetas para el proyecto e-commerce siguiendo feature-based architecture. Incluye: features/Products, features/Auth, features/Orders, features/Cart, shared/components, shared/hooks, shared/utils"

// 3. Migrar Componentes Legacy
@cursor: "Refactoriza el componente HomePage.tsx legacy del proyecto e-commerce a la nueva estructura. Muévelo a features/Home/pages/HomePage.tsx y aplica mejores prácticas de TypeScript"

// 4. Crear Tipos TypeScript
@cursor: "Genera los tipos TypeScript para el proyecto e-commerce. Incluye interfaces para Product, User, Order, CartItem, etc."
```

### Ejercicio 2: Implementar Feature Products

<CardGrid>
  <Card title="🛍️ Objetivo" icon="star">
    Desarrollar la feature Products completa para el e-commerce con componentes modernos y API integration
  </Card>
  
  <Card title="✅ Resultado Esperado" icon="approve-check">
    - API service funcional con TypeScript
    - Custom hooks con React Query
    - Componentes reutilizables y tipados
    - Manejo de estados loading/error
  </Card>
</CardGrid>

#### Estructura Final Esperada

```typescript
features/Products/
├── components/
│   ├── ProductCard/
│   │   ├── ProductCard.tsx
│   │   ├── ProductCard.module.css
│   │   └── __tests__/
│   └── ProductList/
│       ├── ProductList.tsx
│       ├── ProductList.module.css
│       └── __tests__/
├── pages/
│   ├── ProductsPage.tsx
│   └── ProductDetailPage.tsx
├── hooks/
│   └── useProducts.ts
├── services/
│   └── productsApi.ts
├── types/
│   └── product.types.ts
└── utils/
    └── productHelpers.ts
```

## Métricas de Transformación

| Métrica | Antes | Después | Mejora |
|---------|--------|---------|---------|
| **Líneas de código** | ~200 | ~1,500 | 7.5x |
| **Componentes** | 3 básicos | 15+ modulares | 5x |
| **Features** | 0 | 3 completas | ∞ |
| **Performance** | Básica | Optimizada | 3x |
| **Testing** | 0% | 80%+ | ∞ |
| **Mantenibilidad** | Difícil | Fácil | 10x |

### Skills Desarrollados

- ✅ **Feature-Based Architecture**
- ✅ **React Patterns avanzados**
- ✅ **State Management con Context API**
- ✅ **API Integration patterns**
- ✅ **Performance Optimization**
- ✅ **Testing automatizado**
- ✅ **TypeScript avanzado**
- ✅ **Cursor AI mastery**

:::tip[Filosofía de Prompts Efectivos]
**Regla de Oro**: "Sé específico, contextual y progresivo"

**❌ MAL**: "Haz un componente"

**✅ BIEN**: "Crea un componente ProductCard para un e-commerce que muestre imagen, nombre, precio y botón de agregar al carrito. Usa TypeScript, CSS modules y sigue las mejores prácticas de React 18"
:::

## Troubleshooting de Frontend Común

### Problemas Frecuentes y Soluciones

#### Componentes no se re-renderizan correctamente
```bash
# Verificar dependency arrays en useEffect/useMemo
npm run lint:hooks
```

#### Performance issues con listas grandes
1. Implementar React.memo en componentes de lista
2. Usar useCallback para event handlers
3. Considerar virtualización para >1000 items

#### Context re-renders excesivos
```tsx
// Dividir contextos por funcionalidad
// Usar múltiples providers específicos en lugar de uno global
```

:::tip[Más Ayuda]
Para más problemas de desarrollo frontend, consulta [Frontend Troubleshooting](https://docs.cursor.com/troubleshooting/frontend).
:::

## Próximo Paso

¡Has completado el Módulo 4! Ahora tienes las habilidades para desarrollar arquitecturas frontend empresariales con Cursor AI. En el [Módulo 5](/modulo-5/), aprenderás desarrollo backend profesional con FastAPI, bases de datos, APIs RESTful y arquitectura de microservicios.